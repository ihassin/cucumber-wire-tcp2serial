<p># Introduction</p></p>It is sometimes useful to have integration tests run on an embedded device while development is ongoing.</p></p>This project implements the Cucumber wire protocol to direct Cucumber step invocations over a serial port so that they run on the target device under test.</p></p>It allows you to use the native Cucumber gem to execute your scripts on your development machine, and executes their steps in a server process that redirects the command execution requests to a serial port to which you connect your target device.</p></p># The components</p></p>The block diagram shows the components and their interaction:</p>![](/Users/ThoughtWorks/Documents/projects/cucumber-tcp2serial/docs/components.png)</p></p># Customising the RPC listener</p></p>The RPC listener on the device needs to be cusomised to your needs. Its intended use is to drive on-board integration tests, so receiving and executing the test suites needs to be defined by you.</p></p>In order to customise the messaging protocol and execution parameters, you need to change the following two files:</p></p>On the server side:</p>1. wire-server-api.c - This file contains the step-definition literals that you want to support.</p>Change the entries in the api-table array. Here, specify the steps' text as well as the pointers to the functions that will execute once that step is invoked by Cucumber.</p></p>Still in this file, implement the function that will be called when its corresponding step is invoked by Cucumber. An example:</p>```c</p>  static int i\_have\_a\_red\_led(struct wire\_context *context)</p>  {</p>      char buff[20];</p></p>      int retVal = serial\_write(context->serialPortHandle, "EXEC 0\n");</p>      serial\_read(context->serialPortHandle, buff, sizeof(buff));</p>      return(retVal);</p>  }</p>```</p>This will send "EXEC 0" to the device. Decide on your protocol and change accordingly.</p></p>On the device side:</p>1. In main.c, change the read loop to execute an API function or a series of calls under tests:</p></p>```c</p>        if (chr == '\n')</p>        {</p>            command_buffer[idx] = 0;</p>            idx = 0;</p>            **printf(command\_buffer);**</p>		}</p>```</p></p>Here, instead of printf(), execute a device API or test based on the parsed command. In our example, it would be in response to "EXEC 0".</p></p># Building the components</p>## Building the gateway</p>```</p>mkdir build</p>cd build</p>cmake ..</p>make</p>```</p></p>## Building the RPC listener</p></p>```</p>cd nrf51-rpc-server</p>make</p>```</p>Don't forget to flash your device with your modified code. You can use ```flash.sh```</p></p># Running the gateway</p></p>Plug the target device into your USB port and issue </p>```ls /dev``` to see the port name assigned to it.</p>Use that port name as the first parameter, the second being the port number to listen on. This has to match the port number lisetd in the features/step\_definitions/cucumber.wire file.</p></p>```</p>cd build</p>cucumber\_tcp2serial /dev/tty.usbmodem1411 3901</p>```</p>This will start the server and you will see logs as it receives commands from the Cucumber gem.</p></p># Running the RPC listener</p>It will automatically run, as the device will execute main() on powerup.</p></p># Example Cucumber script</p></p>```</p>Feature: Hello World</p></p>Scenario: Blink red LED</p>	Given I have a red led</p>	When I turn it on</p>	Then it's lit up</p>```</p></p># Contributing</p></p>1. [Fork it](https://github.com/ihassin/cucumber-wire-tcp2serial.git)</p>2. Create your feature branch (`git checkout -b my-new-feature`)</p>3. Commit your changes (`git commit -am 'Add some feature'`)</p>4. Push to the branch (`git push origin my-new-feature`)</p>5. Create a new Pull Request</p></p># Code of conduct</p></p>Our code of conduct is [here](https://github.com/ihassin/cucumber-wire-tcp2serial/blob/master/CODE_OF_CONDUCT.md).</p></p># License</p></p>MIT.</p>However, Nordic Semiconductor license applies to any NRF51 code used here.</p>